#!/usr/bin/env python3
# Copyright (c) 2024 O.S. Systems Software LTDA.
# Copyright (c) 2024 Freedom Veiculos Eletricos
# SPDX-License-Identifier: Apache-2.0

"""
Utility to autogenerate the behaviour tree tables.

Usage::
    ./generate-zephyrbt-from-behaviourtreecpp-xml -i /path/project_dir
"""

import argparse
import stringcase
from collections import OrderedDict
from pathlib import Path
from functools import reduce
import re
import struct

from natsort import natsorted
import xml.etree.ElementTree as ET

REPO_ROOT = Path(__file__).absolute().parents[1]
HEADER = """/*
 * Autogenerated file
 *
 * SPDX-License-Identifier: UNLICENSED
 */
"""


def compute_columns(errors, additional = 0):
    constant = max([len(fields['constant']) for _, fields in errors.items()])
    return constant + additional + 1


def gen_align(text, tabsize = 8):
    align = ""
    size = len(text)
    while(size >= tabsize):
        align = align + "\t"
        size = size - tabsize
    return align + "".rjust(size, " ")


def get_unique_custom_nodes(nodes):
    custom_unique_set = []

    for uid, num, function, model, custom, comment, attribs in nodes:
        if custom is False: continue
        if len([info for info in custom_unique_set if info[2] == function]) != 0: continue

        custom_unique_set.append([uid, num, function, model, custom, comment, attribs])

    return custom_unique_set


def has_builtin_node_init(builtin, function):
    for node in builtin:
        func, node_type, has_init, *_ = node
        if function == func:
            return has_init
    return False


def get_blackboard_item(item):
    if item == None:
        return "NULL"
    if item == '':
        return "NULL"
    if item.startswith("{") and item.endswith("}"):
        return "NULL"
    if item.isdigit():
        return f"(zephyrbt_node_context_t){item}"

    try:
        fvalue = float(item)
        fdata = struct.pack('f', fvalue)
        ivalue = struct.unpack('i', fdata)
        return f"(zephyrbt_node_context_t){hex(ivalue[0])} /* {item} */"
    except ValueError as ve:
        pass
    return f"(zephyrbt_node_context_t){item}"

def get_blackboard_variable_index(item, blackboard):
    if item == None:
        return -1
    if item == '':
        return -1
    if item.startswith("{") and item.endswith("}") and len(item) > 2:
        value = item[1:-1]
        for entry in blackboard:
            if entry[1] == value:
                return entry[0]
    return -1

def get_blackboard_type(btype):
    if btype == "input_port":
        return "ZEPHYRBT_BLACKBOARD_ITEM_INPUT_TYPE"
    if btype == "output_port":
        return "ZEPHYRBT_BLACKBOARD_ITEM_OUTPUT_TYPE"
    return "ZEPHYRBT_BLACKBOARD_ITEM_INOUT_TYPE"


def write_zephyrbt_function_enum(f, function, attribs):
    if len(attribs) == 0:
        return

    f.write(f"enum zephyrbt_{function}_attributes {{\n")
    for _, _, name, *_ in attribs:
        f.write(f"\tZEPHYRBT_{function.upper()}_ATTRIBUTE_{name.upper()},\n")
    f.write(f"}};\n\n")


def write_zephyrbt_function_prototypes(f, nodes, user_file):
    f.write(f"\n")

    if user_file:
        f.write(f"#include \"zephyrbt_user.h\"\n\n")

    for _, num, function, model, custom, comment, attribs in get_unique_custom_nodes(nodes):
        write_zephyrbt_function_enum(f, function, attribs)

        fname = f"zephyrbt_{model}_{function}("
        f.write(f"enum zephyrbt_child_status\n{fname}struct zephyrbt_context *ctx,\n")
        f.write(f"{gen_align(fname)}struct zephyrbt_node *self);\n\n")

        fname = f"zephyrbt_{model}_{function}_init("
        f.write(f"enum zephyrbt_child_status\n{fname}struct zephyrbt_context *ctx,\n")
        f.write(f"{gen_align(fname)}struct zephyrbt_node *self);\n\n")


def write_zephyrbt_custom_function(f, nodes):
    for _, num, function, model, custom, comment, attribs in get_unique_custom_nodes(nodes):
        fname = f"zephyrbt_{model}_{function}("
        f.write(f"\nenum zephyrbt_child_status __attribute__((weak))")
        f.write(f"\n{fname}struct zephyrbt_context *ctx,\n")
        f.write(f"{gen_align(fname)}struct zephyrbt_node *self)\n{{\n")
        f.write(f"\tLOG_WRN(\"{fname[:-1]} stub function\");\n");
        f.write(f"\treturn ZEPHYRBT_CHILD_SUCCESS_STATUS;\n");
        f.write(f"}}\n");
        fname = f"{fname[0:-1]}_init("
        f.write(f"\nenum zephyrbt_child_status __attribute__((weak))")
        f.write(f"\n{fname}struct zephyrbt_context *ctx,\n")
        f.write(f"{gen_align(fname)}struct zephyrbt_node *self)\n{{\n")
        f.write(f"\tLOG_WRN(\"{fname[:-1]} stub function\");\n");
        f.write(f"\treturn ZEPHYRBT_CHILD_SUCCESS_STATUS;\n");
        f.write(f"}}\n");


def write_zephyrbt_nodes_table(f, nodes, builtin, bt, name):
    f.write(f"\nstatic struct zephyrbt_node {name}[] = {{")
    for node, child, sibling in bt:
        _, num, function, model, custom, comment, attribs = node
        s_idx = sibling[1] if sibling is not None else -1
        c_idx = child[1] if child is not None else -1
        basename = f"zephyrbt_{model}_{function}"
        if not custom and not has_builtin_node_init(builtin, function):
            init_name = "NULL"
        else:
            init_name = f"{basename}_init"
        f.write(f"\n\t{{")
        f.write(f"\n\t\t.function={basename},")
        f.write(f"\n\t\tIF_ENABLED(CONFIG_ZEPHYR_BEHAVIOUR_TREE_NODE_INIT, (")
        f.write(f"\n\t\t\t.init={init_name},")
        f.write(f"\n\t\t))")
        if comment is None:
            fname = f"{function} [{model}, {num}]"
        else:
            fname = f"{comment} [{model}, {num}]"
        f.write(f"\n\t\t.sibling={s_idx},")
        f.write(f"\n\t\t.child={c_idx},")
        f.write(f"\n\t\tIF_ENABLED(CONFIG_ZEPHYR_BEHAVIOUR_TREE_NODE_INFO, (")
        f.write(f"\n\t\t\t.name=\"{fname}\",")
        f.write(f"\n\t\t\t.index={num},")
        f.write(f"\n\t\t))")
        f.write(f"\n\t}},")
    f.write(f"\n}};\n")

def write_zephyrbt_blackboard_table(f, nodes, builtin, bt, blackboard, name):
    f.write(f"\nstatic struct zephyrbt_blackboard_item {name}[] = {{")

    for node in nodes:
        for entry in node[6]:
            f.write(f"\n\t{{")
            if entry[5] is not None:
                f.write(f"\n\t\t/* {entry[5]} */")
            f.write(f"\n\t\t.idx = {node[1]},")
            f.write(f"\n\t\t.ref = {get_blackboard_variable_index(entry[4], blackboard)},")
            f.write(f"\n\t\t.key = ZEPHYRBT_{node[2].upper()}_ATTRIBUTE_{entry[2].upper()},")
            f.write(f"\n\t\t.item = {get_blackboard_item(entry[4])},")
            f.write(f"\n\t\t.type = {get_blackboard_type(entry[3])},")
            f.write(f"\n\t}},")

    for entry in blackboard:
        if entry[0] >= len(nodes):
            f.write(f"\n\t{{")
            f.write(f"\n\t\t.idx = {entry[0]},")
            f.write(f"\n\t\t.ref = -1,")
            f.write(f"\n\t\t.key = ZEPHYRBT_BLACKBOARD_ITEM_ENTRY_KEY,")
            f.write(f"\n\t\t.item = NULL,")
            f.write(f"\n\t\t.type = ZEPHYRBT_BLACKBOARD_ITEM_INOUT_TYPE,")
            f.write(f"\n\t}},")

    f.write(f"\n\t{{")
    f.write(f"\n\t\t.idx = -1,")
    f.write(f"\n\t\t.ref = -1,")
    f.write(f"\n\t\t.key = -1,")
    f.write(f"\n\t\t.item = NULL,")
    f.write(f"\n\t\t.type = 0,")
    f.write(f"\n\t}},")
    f.write(f"\n}};\n")


def generate_files(filename, output_inc, output_data, output_stub, builtin,
                   nodes, bt, blackboard, stack, prio, user_file):
    with open(output_inc, "w") as f:
        f.write(HEADER)
        f.write(f"\n#ifndef {filename.upper()}_H")
        f.write(f"\n#define {filename.upper()}_H\n")
        write_zephyrbt_function_prototypes(f, nodes, user_file)
        f.write(f"#endif /* {filename.upper()}_H */\n")

    with open(output_data, "w") as f:
        node_data_name = f"{filename}_nodes"
        node_blackboard_name = f"{filename}_blackboard"
        f.write(HEADER)
        f.write(f"\n#include <stdint.h>")
        f.write(f"\n#include <zephyr/zephyrbt/zephyrbt.h>")
        f.write(f"\n#include <zephyr/sys/util.h>\n")
        f.write(f"\n#include <zephyr/logging/log.h>")
        f.write(f"\nLOG_MODULE_REGISTER({filename}_data, CONFIG_ZEPHYR_BEHAVIOUR_TREE_LOG_LEVEL);\n")
        f.write(f"\n#include \"{filename}.h\"\n")
        write_zephyrbt_nodes_table(f, nodes, builtin, bt, node_data_name)
        write_zephyrbt_blackboard_table(f, nodes, builtin, bt, blackboard, node_blackboard_name)
        f.write(f"\nZEPHYRBT_DEFINE({filename}, {filename}_nodes, ")
        f.write(f"{stack}, {prio}, NULL, {filename}_blackboard);\n")

    with open(output_stub, "w") as f:
        node_data_name = f"{filename}_nodes"
        f.write(HEADER)
        f.write(f"\n#include <stdint.h>")
        f.write(f"\n#include <zephyr/zephyrbt/zephyrbt.h>")
        f.write(f"\n#include <zephyr/sys/util.h>\n")
        f.write(f"\n#include <zephyr/logging/log.h>")
        f.write(f"\nLOG_MODULE_REGISTER({filename}_stub, CONFIG_ZEPHYR_BEHAVIOUR_TREE_LOG_LEVEL);\n")
        f.write(f"\n#include \"{filename}.h\"\n")
        write_zephyrbt_custom_function(f, nodes)


def getBuiltIn(builtin, name, custom):
    for function, model, *_ in builtin:
        if function == name:
            return function, model, custom

    return None, None, custom


def searchSubTree(builtin, idx_nodes_set, custom_set, num, elem, root):
    for tree in root.iter('BehaviorTree'):
        if tree.attrib.get('ID') != elem.get('ID'):
            continue
        return parseNodes(builtin, idx_nodes_set, custom_set, num, tree[0], root)
    raise Exception("Abort due to SubTree errors")


def parseNodes(builtin, idx_nodes_set, custom_set, num, elem, root):
    for subelem in reversed(elem):
        num = parseNodes(builtin, idx_nodes_set, custom_set, num, subelem, root)

    # Replace by SubTree
    if elem.tag == 'SubTree':
        return searchSubTree(builtin, idx_nodes_set, custom_set, num, elem, root)

    comment = elem.attrib.get('name')

    function, model, custom = getBuiltIn(builtin, stringcase.snakecase(elem.tag), False)
    if function is None:
        function, model, custom = getBuiltIn(custom_set, stringcase.snakecase(elem.tag), True)

    attrib_set = []
    for att in elem.attrib:
        if att == 'name': continue
        if att == '_description': continue
        attrib_set.append([att, elem.attrib.get(att)])

    idx_nodes_set.append([id(elem), num, function, model, custom, comment, attrib_set])

    return num + 1


def getIndexedNode(idx_table, elem):
    for idx in idx_table:
        if id(elem) == idx[0]:
            return idx
    return None


def getSearchNode(idx_table, elem):
    for idx in idx_table:
        if elem == idx[2]:
            return idx
    return None


def getSearchBuiltinNode(builtin, name):
    for idx in builtin:
        if name == idx[0]:
            return idx
    return None


def getChildIdx(idx_table, num, elem, root, mainroot):
    child = None
    if elem:
        for subelem in elem:
            if subelem.tag == "SubTree":
                subelem = resolveSubTree(subelem, mainroot)
                if subelem is None:
                    continue
            child = getIndexedNode(idx_table, subelem)
            break

    return child

def resolveSubTree(elem, mainroot):
    for tree in mainroot.iter('BehaviorTree'):
        if tree.attrib.get('ID') != elem.get('ID'):
            continue
        return tree[0]
    return None

def assemblySubTree(builtin, idx_nodes_set, bt_set, num, elem, root, mainroot):
    for tree in mainroot.iter('BehaviorTree'):
        if tree.attrib.get('ID') != elem.get('ID'):
            continue
        return assemblyBT(builtin, idx_nodes_set, bt_set, num, tree[0], root, mainroot)
    raise Exception("Abort due to SubTree errors")


def assemblyBT(builtin, idx_nodes_set, bt_set, num, elem, root, mainroot):
    for subelem in reversed(elem):
        num = assemblyBT(builtin, idx_nodes_set, bt_set, num, subelem, elem, mainroot)

    # Replace by SubTree
    if elem.tag == 'SubTree':
        return assemblySubTree(builtin, idx_nodes_set, bt_set, num, elem, root, mainroot)

    prev = None
    if elem != root:
        for subelem in reversed(root):
            if subelem.tag == "SubTree":
                subelem = resolveSubTree(subelem, mainroot)
                if subelem is None:
                    continue
            if elem != subelem:
                prev = subelem
                continue
            break

    bt_set.append([getIndexedNode(idx_nodes_set, elem),
                   getChildIdx(idx_nodes_set, num, elem, root, mainroot),
                   getIndexedNode(idx_nodes_set, prev)])

    return num + 1


def parseCustomNodes(custom_set, elem):
    custom_set.append([stringcase.snakecase(elem.attrib.get('ID')), stringcase.snakecase(elem.tag), True])


def parseBlackboardEntry(idx_nodes_set, blackboard_set, elem):
    node_index = getSearchNode(idx_nodes_set, stringcase.snakecase(elem.attrib.get('ID')))
    for e in elem:
        name = e.attrib.get('name')
        default = e.attrib.get('default')
        if not node_index:
            continue
        blackboard_set.append([-1, node_index[2], name, e.tag, default, e.text])


def addBuiltinBlackboard(idx_nodes_set, blackboard_set, builtin):
    for node in builtin:
        node_index = getSearchNode(idx_nodes_set, node[0])
        if node_index:
            for port in node[3]:
                blackboard_set.append([-1, node_index[2], port[0], port[1], port[2], port[3]])


def loadBlackboardEntries(node_type, blackboard_set):
    entries = []
    for entry in blackboard_set:
        if entry[1] == node_type:
            entries.append(entry)
    return entries


def loadBlackboardVariables(index, variable, blackboard_set):
    if len(variable) <= 2:
        return index

    if variable.startswith("{") and variable.endswith("}"):
        entry = variable[1:-1]
        matches = [item for item in blackboard_set if item[1] == entry]
        if not matches:
            blackboard_set.append([index, entry, '', 'inout_port', '', ''])
            index = index + 1

    return index


def addBlackboardVariables(idx_nodes_set, blackboard_set):
    index = len(idx_nodes_set)

    for node in blackboard_set:
        index = loadBlackboardVariables(index, str(node[4]), blackboard_set)

    for node in idx_nodes_set:
        blackboard = node[6]
        if blackboard:
            index = loadBlackboardVariables(index, str(blackboard[0][1]), blackboard_set)


def build_bt_set(builtin, root):
    main = root.attrib.get('main_tree_to_execute')

    custom_set = []
    idx_nodes_set = []
    bt_set = []
    blackboard_set = []

    for elem in root.iter('TreeNodesModel'):
        for e in elem:
            parseCustomNodes(custom_set, e)

    for elem in root.iter('BehaviorTree'):
        if elem.attrib.get('ID') != main:
            continue

        parseNodes(builtin, idx_nodes_set, custom_set, 0, elem[0], root)
        assemblyBT(builtin, idx_nodes_set, bt_set, 0, elem[0], elem[0], root)
        break

    addBuiltinBlackboard(idx_nodes_set, blackboard_set, builtin)
    for elem in root.iter('TreeNodesModel'):
        for e in elem:
            parseBlackboardEntry(idx_nodes_set, blackboard_set, e)

    addBlackboardVariables(idx_nodes_set, blackboard_set)

    for node_idx in range(0, len(idx_nodes_set)):
        node = idx_nodes_set[node_idx]
        node_type = node[2]
        attribs = node[6]
        bb_entries = loadBlackboardEntries(node_type, blackboard_set)

        if len(bb_entries) == 0:
            continue

        for entry_idx in range(0, len(bb_entries)):
            entry = bb_entries[entry_idx]
            for name, value in attribs:
                if entry[2] == name:
                    entry[4] = value
            bb_entries[entry_idx] = entry
        node[6] = bb_entries
        idx_nodes_set[node_idx] = node

    return idx_nodes_set, bt_set, blackboard_set


def clean_files(filename, dir):
    if dir.exists():
        for entry in dir.glob(filename):
            entry.unlink()
    else:
        dir.mkdir()


def main(zephyrbt_filename, output_inc, output_data, output_stub,
         stack, prio, user_file) -> None:
    zephyrbt = Path(zephyrbt_filename).stem

    sleep =    [['msec', 'input_port', None, 'Wait the amount of milliseconds']]
    setblackboard = [
                ['value', 'input_port', None, 'Value is a param that can be represented as an integer (macro, CONFIG_, constant, 0x, etc)'],
                ['output_key', 'inout_port', None, 'Name of the blackboard entry where the value should be written']
               ]

    parallel = [['failure_count', 'input_port', '1', 'number of children which need to fail to trigger a FAILURE'],
                ['success_count', 'input_port', '-1', 'number of children which need to succeed to trigger a SUCCESS']
               ]
    delay =    [['delay_msec', 'input_port', None, 'Tick the child after a few milliseconds']]
    repeat =   [['num_cycles', 'input_port', None, 'Repeat a successful child up to N times. Use -1 to create an infinite loop']]
    timeout =  [['msec', 'input_port', None, 'After a certain amount of time, halt() the child if it is still running']]
    runonce =  [['then_skip', 'input_port', True, 'If true, skip after the first execution, otherwise return the same NodeStatus returned once by the child']]

    #                  node_name,     type, has_init, blackboard_attributes
    builtin = [('always_success', 'action',    False, []),
               ('always_failure', 'action',    False, []),
               ('sleep',          'action',    True,  sleep),
               ('set_blackboard', 'action',    True,  setblackboard),
               ('fallback',       'control',   False, []),
               ('sequence',       'control',   False, []),
               ('parallel',       'control',   True,  parallel),
               ('inverter',       'decorator', False, []),
               ('delay',          'decorator', True,  delay),
               ('repeat',         'decorator', True,  repeat),
               ('run_once',       'decorator', True,  runonce),
               ('timeout',        'decorator', True,  timeout),
              ]

    if not Path(zephyrbt_filename).is_file():
        raise ValueError(f"The file '{zephyrbt_filename}' was not found.")

    tree = ET.parse(zephyrbt_filename)
    root = tree.getroot()

    format = root.attrib.get('BTCPP_format')
    if format is None:
        print('Not a BehaviourTree-CPP XML file.')
        exit -1

    if int(format) < 4:
        print('Incompatible version')
        exit -1

    print("-- Behaviour Tree: ", zephyrbt)
    print("-- Stack Size:     ", stack)
    print("-- Thread Priority:", prio)

    nodes, bt, blackboard = build_bt_set(builtin, root)
    generate_files(zephyrbt, output_inc, output_data, output_stub, builtin,
                   nodes, bt, blackboard, stack, prio, user_file)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-i",
        "--input",
        type=Path,
        default=REPO_ROOT,
        help="The behaviour tree input file",
    )
    parser.add_argument(
        "-oi",
        "--outinc",
        type=Path,
        default=REPO_ROOT,
        help="Header file that will be generated",
    )
    parser.add_argument(
        "-os",
        "--outdata",
        type=Path,
        default=REPO_ROOT,
        help="Data structure file that will be generated",
    )
    parser.add_argument(
        "-ot",
        "--outstub",
        type=Path,
        default=REPO_ROOT,
        help="Stub functions file that will be generated",
    )
    parser.add_argument(
        "-s",
        "--stack",
        type=int,
        default=2048,
        help="The amount of RAM used to run the BT",
    )
    parser.add_argument(
        "-p",
        "--prio",
        type=int,
        default=0,
        help="The Thread Priority",
    )
    parser.add_argument(
        "-u",
        "--user_file",
        type=bool,
        default=False,
        help="Add user include file into code generation",
    )
    args = parser.parse_args()

    main(args.input, args.outinc, args.outdata, args.outstub,
         args.stack, args.prio, args.user_file)
